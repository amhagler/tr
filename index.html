<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GEFFEN BOWL</title>
  <style>
    :root{
      --bg0:#070B1A;
      --bg1:#0B1230;
      --panel:#0C1638;

      --electric:#2D7DFF;
      --electric2:#1E5BFF;

      --gold:#FFE066;     /* brighter */
      --gold2:#FFB700;    /* hotter */
      --red:#FF5A5A;

      --ink:#EAF0FF;
      --muted:#B7C2E6;

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --shadow2: 0 10px 28px rgba(0,0,0,.35);

      --radius: 18px;
      --radius2: 26px;

      --ring: 0 0 0 2px rgba(45,125,255,.35), 0 0 0 6px rgba(255,224,102,.14);

      --cell-min-h: 76px;
      --maxw: 1200px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(45,125,255,.25), transparent 60%),
        radial-gradient(900px 600px at 90% 10%, rgba(255,183,0,.18), transparent 55%),
        radial-gradient(1200px 900px at 50% 120%, rgba(45,125,255,.18), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* -------------------------
       1993 Title Screen
    -------------------------- */
    #titleScreen{
      position:relative;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }

    #starfield, #starfield2{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    .crt{
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        repeating-linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.03) 1px, transparent 1px, transparent 3px);
      mix-blend-mode: overlay;
      opacity:.30;
      filter: blur(.2px);
    }

    .vignette{
      position:absolute;
      inset:-2px;
      pointer-events:none;
      background: radial-gradient(1200px 700px at 50% 35%, transparent 55%, rgba(0,0,0,.55));
      opacity:.9;
    }

    .title-card{
      position:relative;
      width:min(980px, 92vw);
      padding: 26px 22px 20px;
      border-radius: 26px;
      background:
        radial-gradient(520px 240px at 20% 20%, rgba(255,224,102,.20), transparent 60%),
        radial-gradient(540px 260px at 80% 35%, rgba(45,125,255,.22), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      text-align:center;
    }

    .logo{
      font-weight: 1000;
      letter-spacing: .22em;
      text-transform: uppercase;
      font-size: clamp(30px, 4.2vw, 54px);
      margin: 4px 0 6px;
      text-shadow:
        0 18px 60px rgba(0,0,0,.65),
        0 0 26px rgba(45,125,255,.25),
        0 0 42px rgba(255,224,102,.16);
    }

    .tagline{
      color: var(--muted);
      letter-spacing:.10em;
      text-transform: uppercase;
      font-weight: 900;
      font-size: 12px;
      margin-bottom: 14px;
    }

    .glowbar{
      width:min(720px, 86vw);
      margin: 10px auto 18px;
      height: 2px;
      border-radius: 999px;
      background: linear-gradient(90deg, transparent, rgba(45,125,255,.55), rgba(255,224,102,.70), rgba(45,125,255,.55), transparent);
      filter: drop-shadow(0 0 14px rgba(255,224,102,.18));
      opacity:.95;
    }

    .title-grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
      align-items: start;
    }

    @media (max-width: 860px){
      .title-grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: 20px;
      padding: 14px 14px;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow2);
      text-align:left;
    }

    .panel h3{
      margin: 0 0 10px;
      font-size: 12px;
      letter-spacing:.14em;
      text-transform: uppercase;
      color: var(--gold);
      font-weight: 950;
    }

    .row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:flex-start;
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 180px;
      flex: 1;
    }

    label{
      font-size: 11px;
      letter-spacing:.08em;
      text-transform: uppercase;
      color: rgba(183,194,230,.95);
      font-weight: 900;
    }

    select, input[type="number"], input[type="text"], textarea{
      width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      padding: 10px 10px;
      outline:none;
      font-weight: 800;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    select:focus, input:focus, textarea:focus{ box-shadow: var(--shadow2), var(--ring); border-color: rgba(45,125,255,.55); }

    .toggles{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      margin-top: 8px;
    }

    .toggle{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      cursor:pointer;
      user-select:none;
    }
    .toggle:hover{ border-color: rgba(45,125,255,.45); }

    .toggle input{ width:18px; height:18px; }

    .title-actions{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      justify-content:center;
      margin-top: 14px;
    }

    button{
      border:none;
      cursor:pointer;
      padding: 11px 16px;
      border-radius: 999px;
      color: var(--ink);
      font-weight: 950;
      letter-spacing: .02em;
      background:
        radial-gradient(150px 90px at 20% 20%, rgba(45,125,255,.25), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      transition: transform .12s ease, border-color .2s ease, box-shadow .2s ease, background .2s ease, filter .2s ease;
      user-select:none;
    }
    button:hover{
      transform: translateY(-1px);
      border-color: rgba(45,125,255,.55);
      box-shadow: 0 14px 30px rgba(0,0,0,.42);
    }
    button:active{ transform: translateY(0px) scale(.99); }

    .btn-gold{
      background:
        radial-gradient(160px 100px at 20% 20%, rgba(255,224,102,.65), transparent 60%),
        linear-gradient(180deg, rgba(255,224,102,.42), rgba(255,255,255,.06));
      border-color: rgba(255,224,102,.55);
      color: #070B1A;
      text-shadow:none;
    }
    .btn-danger{
      background:
        radial-gradient(160px 100px at 20% 20%, rgba(255,90,90,.25), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-color: rgba(255,90,90,.40);
    }

    .tiny{
      font-size: 12px;
      color: rgba(183,194,230,.92);
      line-height: 1.35;
    }
    .tiny kbd{
      display:inline-block;
      padding: 2px 7px;
      border-radius: 8px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
      font-weight: 950;
      color: var(--ink);
      margin: 0 4px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    /* -------------------------
       Game Screen
    -------------------------- */
    #gameScreen{
      display:none;
      min-height:100vh;
    }

    header.game{
      position: sticky;
      top: 0;
      z-index: 5;
      padding: 16px 16px 10px;
      background: linear-gradient(180deg, rgba(11,18,48,.92), rgba(11,18,48,.55));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    .topbar{
      max-width: var(--maxw);
      margin: 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      flex-wrap:wrap;
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap: 4px;
      text-align:left;
    }

    .brand .h{
      font-weight: 1000;
      letter-spacing: .18em;
      text-transform: uppercase;
      margin:0;
      font-size: 18px;
      text-shadow: 0 12px 40px rgba(0,0,0,.55);
    }

    .brand .s{
      font-size: 11px;
      letter-spacing:.08em;
      text-transform: uppercase;
      color: var(--muted);
      font-weight: 900;
    }

    .header-controls{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }

    .teams{
      max-width: var(--maxw);
      margin: 12px auto 0;
      display:flex;
      justify-content:center;
      gap: clamp(10px, 2vw, 14px);
      flex-wrap:wrap;
    }

    .team{
      width: 210px;
      height: 116px;
      border-radius: 22px;
      background:
        radial-gradient(160px 100px at 30% 15%, rgba(255,224,102,.16), transparent 60%),
        radial-gradient(220px 120px at 60% 80%, rgba(45,125,255,.16), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow2);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      gap: 8px;
      cursor:pointer;
      transition: transform .15s ease, box-shadow .2s ease, border-color .2s ease;
      user-select:none;
      position:relative;
    }
    .team:hover{
      transform: translateY(-1px);
      border-color: rgba(45,125,255,.35);
      box-shadow: 0 16px 40px rgba(0,0,0,.45);
    }
    .team.active{
      box-shadow: var(--shadow), 0 0 0 2px rgba(45,125,255,.35), 0 0 40px rgba(45,125,255,.22);
      border-color: rgba(45,125,255,.55);
      transform: translateY(-2px);
    }

    .editable{
      outline:none;
      display:inline-block;
      cursor:text;
      padding: 2px 6px;
      border-radius: 10px;
    }
    .editable:hover{
      background: rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }

    .team .name{
      font-weight: 950;
      letter-spacing:.04em;
      font-size: 16px;
      max-width: 188px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .team .score{
      font-weight: 1000;
      font-size: 32px;
      line-height: 1;
      color: var(--gold);
      text-shadow:
        0 14px 40px rgba(0,0,0,.60),
        0 0 22px rgba(255,183,0,.30),
        0 0 44px rgba(255,224,102,.18);
      padding: 4px 10px;
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      min-width: 92px;
      text-align:center;
    }

    main{
      padding: 16px 16px 64px;
      max-width: var(--maxw);
      margin: 0 auto;
    }

    .boardWrap{
      margin-top: 14px;
    }

    .roundBanner{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
      margin: 10px 0 10px;
    }

    .roundPill{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 24px rgba(0,0,0,.30);
      color: var(--muted);
      font-weight: 950;
      letter-spacing:.08em;
      text-transform: uppercase;
      font-size: 12px;
      white-space:nowrap;
    }
    .roundPill strong{ color: var(--ink); letter-spacing:.02em; }

    .winner{
      display:none;
      padding: 14px 14px;
      border-radius: 18px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,224,102,.22);
      box-shadow: var(--shadow2);
      font-size: 16px;
      font-weight: 1000;
      letter-spacing:.02em;
      color: var(--gold);
      text-shadow: 0 14px 40px rgba(0,0,0,.60);
    }

    .board{
      display:grid;
      gap: 14px;
      width: 100%;
      align-items: stretch;
    }

    .cell{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      box-shadow: 0 14px 30px rgba(0,0,0,.35);
      padding: 14px 10px;
      min-height: var(--cell-min-h);
      display:flex;
      align-items:center;
      justify-content:center;
      transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease, filter .2s ease, opacity .2s ease;
      user-select:none;
      position:relative;
      overflow:hidden;
    }
    .cell.clickable:hover{
      transform: translateY(-2px);
      border-color: rgba(45,125,255,.65);
      box-shadow: 0 18px 40px rgba(0,0,0,.45), 0 0 34px rgba(45,125,255,.20);
      cursor:pointer;
    }

    .cell .value{
      font-weight: 1000;
      font-size: clamp(22px, 2.6vw, 34px);
      letter-spacing: .04em;
      text-shadow: 0 14px 40px rgba(0,0,0,.55);
      color: var(--ink);
    }

    /* Category headers */
    .cell.category{
      background: linear-gradient(180deg, rgba(255,224,102,.98), rgba(255,183,0,.88));
      border-color: rgba(255,224,102,.65);
      cursor:default;
    }
    .cell.category .cat{
      font-weight: 1000;
      letter-spacing: .12em;
      text-transform: uppercase;
      font-size: 13px;
      color: #070B1A;
      text-shadow:none;
      line-height: 1.2;
      text-align:center;
    }

    /* States: MORE obvious */
    .cell.answered{
      opacity: .30;
      filter: grayscale(.2) saturate(.25);
      background: linear-gradient(180deg, rgba(255,224,102,.20), rgba(255,255,255,.04));
      border-color: rgba(255,224,102,.22);
      cursor:default;
    }
    .cell.missed{
      opacity: .28;
      filter: grayscale(.35) saturate(.20);
      background: linear-gradient(180deg, rgba(255,90,90,.18), rgba(255,255,255,.03));
      border-color: rgba(255,90,90,.22);
      cursor:default;
    }
    .cell.expired{
      opacity: .26;
      filter: grayscale(.45) saturate(.18);
      background: linear-gradient(180deg, rgba(45,125,255,.12), rgba(255,255,255,.02));
      border-color: rgba(45,125,255,.18);
      cursor:default;
    }

    /* Stamps */
    .cell.answered::after,
    .cell.missed::after,
    .cell.expired::after{
      position:absolute;
      inset:auto 10px 10px auto;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 1000;
      letter-spacing:.12em;
      text-transform: uppercase;
      font-size: 11px;
      color: rgba(234,240,255,.92);
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 24px rgba(0,0,0,.30);
    }
    .cell.answered::after{ content:"DONE"; border-color: rgba(255,224,102,.28); color: rgba(255,224,102,.95); }
    .cell.missed::after{ content:"MISSED"; border-color: rgba(255,90,90,.26); color: rgba(255,90,90,.95); }
    .cell.expired::after{ content:"TIME"; border-color: rgba(45,125,255,.24); color: rgba(45,125,255,.95); }

    /* Double mode badge */
    .double-on .cell.clickable::before{
      content:"×2";
      position:absolute;
      top:10px;
      right:12px;
      font-weight: 1000;
      font-size: 12px;
      letter-spacing:.10em;
      color: rgba(255,224,102,.98);
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,224,102,.35);
      padding: 4px 8px;
      border-radius: 999px;
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
    }

    /* -------------------------
       Backdrop + Modal
    -------------------------- */
    .backdrop{
      display:none;
      position:fixed;
      inset:0;
      background: radial-gradient(1000px 700px at 50% 20%, rgba(45,125,255,.18), rgba(0,0,0,.72));
      backdrop-filter: blur(6px);
      z-index: 20;
    }
    .backdrop.show{ display:block; }

    .modal{
      display:none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(.96);
      width: min(980px, 94vw);
      height: min(74vh, 720px);
      background: linear-gradient(180deg, rgba(10,16,40,.98), rgba(7,11,26,.98));
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 26px;
      box-shadow: var(--shadow), 0 0 60px rgba(45,125,255,.14);
      z-index: 25;
      padding: 18px 18px 16px;
      overflow:hidden;
      text-align:center;
    }
    .modal.show{
      display:block;
      animation: popIn .18s ease-out forwards;
    }
    @keyframes popIn{
      from{ transform: translate(-50%, -50%) scale(.92); opacity:0; }
      to{ transform: translate(-50%, -50%) scale(1); opacity:1; }
    }

    .qa-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      padding: 2px 4px 10px;
      color: var(--muted);
      font-weight: 1000;
      letter-spacing:.08em;
      text-transform: uppercase;
      font-size: 12px;
      flex-wrap:wrap;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 24px rgba(0,0,0,.30);
      color: var(--muted);
      white-space: nowrap;
    }
    .pill strong{ color: var(--ink); letter-spacing:.02em; }

    .vis{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .vis .pill{
      padding: 7px 10px;
      font-size: 11px;
    }
    .vis .ok{ border-color: rgba(255,224,102,.22); color: rgba(255,224,102,.95); }
    .vis .no{ border-color: rgba(255,90,90,.18); color: rgba(183,194,230,.95); opacity:.9; }

    .question{
      font-size: clamp(24px, 3.2vw, 46px);
      font-weight: 1000;
      letter-spacing: .01em;
      line-height: 1.12;
      margin: 10px auto 0;
      max-width: 920px;
      text-shadow: 0 18px 60px rgba(0,0,0,.70);
      padding: 18px 18px;
      border-radius: 18px;
      background: rgba(0,0,0,.40);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 55px rgba(0,0,0,.45);
    }

    .answer{
      font-size: clamp(18px, 2.2vw, 30px);
      font-weight: 950;
      letter-spacing: .01em;
      margin: 16px auto 0;
      max-width: 920px;
      padding: 14px 14px;
      border-radius: 18px;
      background: rgba(0,0,0,.48);
      border: 1px solid rgba(255,183,0,.24);
      color: rgba(234,240,255,.95);
      text-shadow: 0 14px 40px rgba(0,0,0,.65);
      min-height: 56px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .answer.revealed{
      box-shadow: 0 0 50px rgba(255,183,0,.18), 0 18px 55px rgba(0,0,0,.45);
      border-color: rgba(255,183,0,.44);
    }

    .modal-controls{
      position:absolute;
      left: 0;
      right: 0;
      bottom: 104px;
      padding: 0 18px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      align-items:center;
    }

    .team-buttons{
      display:flex;
      gap: 10px;
      justify-content:center;
      flex-wrap:wrap;
      width: 100%;
    }

    .team-button{
      min-width: 220px;
      font-size: 16px;
      padding: 12px 16px;
    }
    .team-button.primary{
      background:
        radial-gradient(160px 100px at 20% 20%, rgba(255,224,102,.65), transparent 60%),
        linear-gradient(180deg, rgba(255,224,102,.42), rgba(255,255,255,.06));
      border-color: rgba(255,224,102,.55);
      color: #070B1A;
    }

    .row-buttons{
      display:flex;
      gap: 10px;
      justify-content:center;
      flex-wrap:wrap;
    }
    .row-buttons button{ min-width: 160px; }

    .timer{
      position:absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: clamp(34px, 5vw, 70px);
      font-weight: 1000;
      letter-spacing:.06em;
      color: var(--gold);
      text-shadow:
        0 18px 60px rgba(0,0,0,.65),
        0 0 26px rgba(255,183,0,.35),
        0 0 52px rgba(255,224,102,.22);
      padding: 8px 18px;
      border-radius: 999px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 14px 36px rgba(0,0,0,.38);
      min-width: 120px;
    }
    .timer.low{
      animation: pulse 0.8s infinite ease-in-out;
      box-shadow: 0 0 60px rgba(255,183,0,.24), 0 18px 60px rgba(0,0,0,.60);
    }
    @keyframes pulse{
      0%{ transform: translateX(-50%) scale(1); }
      50%{ transform: translateX(-50%) scale(1.05); }
      100%{ transform: translateX(-50%) scale(1); }
    }

    .time-overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      font-size: clamp(40px, 7vw, 92px);
      font-weight: 1000;
      letter-spacing:.18em;
      text-transform: uppercase;
      color: rgba(234,240,255,.92);
      text-shadow: 0 20px 80px rgba(0,0,0,.75);
      background: radial-gradient(700px 500px at 50% 40%, rgba(255,90,90,.22), rgba(0,0,0,.70));
      backdrop-filter: blur(2px);
    }
    .time-overlay.show{ display:flex; }

    /* Round splash */
    .splash{
      display:none;
      position:fixed;
      inset:0;
      z-index: 40;
      background:
        radial-gradient(900px 540px at 50% 25%, rgba(255,224,102,.18), transparent 60%),
        radial-gradient(900px 540px at 50% 30%, rgba(45,125,255,.20), transparent 62%),
        rgba(0,0,0,.66);
      backdrop-filter: blur(8px);
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 18px;
    }
    .splash.show{ display:flex; }
    .splash .box{
      width: min(920px, 92vw);
      padding: 22px 18px;
      border-radius: 26px;
      background: rgba(0,0,0,.40);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
    }
    .splash .big{
      font-size: clamp(30px, 6vw, 78px);
      font-weight: 1000;
      letter-spacing: .20em;
      text-transform: uppercase;
      margin: 6px 0 10px;
      text-shadow: 0 18px 60px rgba(0,0,0,.70);
    }
    .splash .small{
      color: var(--muted);
      letter-spacing:.10em;
      text-transform:uppercase;
      font-weight: 950;
      font-size: 12px;
      margin-bottom: 16px;
    }

    /* -------------------------
       Builder (Phase 2B style)
    -------------------------- */
    .builder{
      display:none;
      position:fixed;
      inset: 5vh 4vw;
      z-index: 60;
      background: linear-gradient(180deg, rgba(10,16,40,.98), rgba(7,11,26,.98));
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 26px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .builder.show{ display:block; }

    .builderHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 14px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      flex-wrap:wrap;
    }
    .builderHead h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.14em;
      text-transform:uppercase;
      font-weight: 1000;
      color: var(--ink);
    }

    .builderBody{
      height: calc(100% - 64px);
      overflow:auto;
      padding: 14px 14px 18px;
    }

    .catBlock{
      padding: 14px 14px;
      border-radius: 20px;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      margin-bottom: 14px;
    }

    .catTop{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }

    .catName{
      font-weight: 1000;
      letter-spacing:.08em;
      text-transform: uppercase;
      font-size: 12px;
      color: var(--gold);
    }

    .qRow{
      display:grid;
      grid-template-columns: 1.3fr 1fr 100px 120px;
      gap: 10px;
      align-items:center;
      margin: 10px 0;
    }
    @media (max-width: 980px){
      .qRow{ grid-template-columns: 1fr; }
    }
    .qRow .mini{
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing:.10em;
      color: rgba(183,194,230,.92);
      font-weight: 950;
      margin-bottom: 4px;
    }

    .qBox{
      display:flex;
      flex-direction:column;
      gap: 6px;
    }

    .qRow input[type="text"]{ width:100%; }
    .qRow input[type="number"]{ width: 100%; }

    .hr{
      height:1px;
      background: rgba(255,255,255,.08);
      margin: 10px 0;
    }

    /* Projector mode hint */
    .projHint{
      display:none;
      margin-left: 8px;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,224,102,.22);
      background: rgba(0,0,0,.20);
      color: rgba(255,224,102,.95);
      font-weight: 1000;
      font-size: 11px;
      letter-spacing:.10em;
      text-transform: uppercase;
      white-space:nowrap;
    }

    /* Projector-only UI adjustments */
    body.projector header.game .header-controls,
    body.projector header.game .teams,
    body.projector .winner,
    body.projector .header-controls,
    body.projector .team{ cursor:default; }
    body.projector .editable{ cursor:default; }
    body.projector .header-controls button{ display:none; }

    .projectorTop{
      display:none;
      max-width: var(--maxw);
      margin: 0 auto 10px;
      padding: 10px 0 0;
      text-align:right;
    }
    body.projector .projectorTop{ display:block; }

    .statusDot{
      display:inline-block;
      width:10px;
      height:10px;
      border-radius:999px;
      background: rgba(255,90,90,.9);
      box-shadow: 0 0 18px rgba(255,90,90,.25);
      margin-right:8px;
      vertical-align:middle;
    }
    .statusDot.ok{
      background: rgba(45,125,255,.9);
      box-shadow: 0 0 18px rgba(45,125,255,.25);
    }

    /* -------------------------
       NEW: Slot manager modal
    -------------------------- */
    .slotModalBody{
      max-width: 920px;
      margin: 10px auto 0;
      text-align:left;
      overflow:auto;
      height: calc(100% - 56px);
      padding-right: 6px;
    }
  </style>
</head>

<body>
  <!-- TITLE SCREEN -->
  <section id="titleScreen" aria-label="Title screen">
    <canvas id="starfield"></canvas>
    <canvas id="starfield2"></canvas>
    <div class="crt"></div>
    <div class="vignette"></div>

    <div class="title-card">
      <div class="logo">GEFFEN BOWL</div>
      <div class="tagline">Powerful Communication • Adaptable Learning • Restorative Trivia • Like Regular Trivia but more *Geffen* </div>
      <div class="glowbar"></div>

      <div class="title-grid">
        <div class="panel">
          <h3>Game Setup</h3>

          <div class="row">
            <div class="field">
              <label for="teamCount">Teams (2–6)</label>
              <select id="teamCount">
                <option value="2">2 Teams</option>
                <option value="3" selected>3 Teams</option>
                <option value="4">4 Teams</option>
                <option value="5">5 Teams</option>
                <option value="6">6 Teams</option>
              </select>
            </div>

            <div class="field">
              <label for="gameMode">Mode</label>
              <select id="gameMode">
                <option value="classic" selected>Classic (1 round)</option>
                <option value="tworound">Two-Round (Round 1 + Round 2)</option>
                <option value="lightning">Lightning (shorter timer defaults)</option>
                <option value="tournament">Tournament (locks edits midgame)</option>
              </select>
            </div>

            <div class="field">
              <label for="timerDefault">Timer (seconds)</label>
              <input id="timerDefault" type="number" min="1" max="240" value="10" />
            </div>
          </div>

          <div class="toggles">
            <label class="toggle" title="Autosave game state so refresh doesn't wipe everything">
              <input type="checkbox" id="autosaveToggle" checked />
              <span>Autosave</span>
            </label>

            <label class="toggle" title="Adds a separate read-only projector window">
              <input type="checkbox" id="projectorToggle" checked />
              <span>Projector Mode</span>
            </label>

            <label class="toggle" title="Prevents accidental answer reveals on the projector">
              <input type="checkbox" id="safeModeToggle" checked />
              <span>SAFE MODE (Projector)</span>
            </label>

            <label class="toggle" title="Default behavior for the Show Answer button">
              <input type="checkbox" id="defaultRevealBothToggle" />
              <span>Default reveal BOTH</span>
            </label>
          </div>

          <div style="margin-top:10px;" class="tiny">
            Host hotkeys (in question): <kbd>1</kbd>–<kbd>6</kbd> award • <kbd>A</kbd> host answer • <kbd>Shift</kbd>+<kbd>A</kbd> projector answer • <kbd>Space</kbd> pause • <kbd>Esc</kbd> close • <kbd>U</kbd> undo
          </div>
        </div>

        <div class="panel">
          <h3>Questions</h3>

          <!-- NEW: JSON template + copy button -->
          <div class="tiny" style="margin-bottom:10px;">
            You can paste JSON <em>or</em> build questions inside the editor.
            Old JSON still works (loads as Round 1).
          </div>

          <div class="row" style="margin-bottom:10px;">
            <button class="btn-gold" id="openBuilderFromTitle">Open Question Builder</button>
            <button id="pasteJsonFromTitle">Paste JSON</button>
            <button id="copyJsonTemplateBtn" title="Copy a starter JSON template">Copy JSON Template</button>
          </div>

          <div class="field" style="margin-bottom:10px;">
            <label for="saveSlotSelect">Save Slot</label>
            <div style="display:flex; gap:10px; align-items:center;">
              <select id="saveSlotSelect" style="flex:1; min-width:240px;"></select>
              <button id="manageSlotsBtn" title="Create, rename, or delete save slots">Manage</button>
            </div>
            <div class="tiny" style="margin-top:6px;">
              Each slot is its own saved game (perfect for C block vs D block). Switch slots to resume that class.
            </div>
          </div>

          <div style="margin-top:10px;">
            <textarea id="jsonInputTitle" placeholder="Paste JSON here (optional)"></textarea>
          </div>

          <div class="title-actions">
            <button class="btn-gold" id="startFromTitle">Start GEFFEN BOWL</button>
            <button id="exportSaveBtn" title="Download the current slot's saved game as a file">Export Save</button>
            <button id="importSaveBtn" title="Import a previously exported save file">Import Save</button>
            <button class="btn-danger" id="clearSaveBtn">Clear Saved Game</button>
          </div>

          <input id="importFileInput" type="file" accept="application/json" style="display:none;" />

          <div class="tiny" style="margin-top:8px;">
            Tip: if popups are blocked, allow popups for this page so the projector window can open.
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- GAME SCREEN -->
  <section id="gameScreen" aria-label="Game screen">
    <header class="game">
      <div class="topbar">
        <div class="brand">
          <div class="h">GEFFEN BOWL</div>
          <div class="s" id="subtitle">History is not trivia • Trivia is not history • Facts and truths are not the same thing</div>
        </div>

        <div class="header-controls">
          <button id="openBuilderBtn">Question Builder</button>
          <button id="copyJsonBtn" title="Copy current questions (all rounds) as JSON">Copy JSON</button>
          <button id="toggleDoubleBtn">Double: OFF</button>
          <button id="openProjectorBtn">Open Projector</button>
<button id="nextRoundBtn">Next Round</button>
          <button class="btn-danger" id="returnToTitleBtn">Title Screen</button>
        </div>
      </div>

      <div class="projectorTop" id="projectorTop">
        <span class="statusDot" id="projStatusDot"></span>
        <span class="projHint" id="projHint">PROJECTOR CONNECTED</span>
        <button class="btn-gold" id="projectorFullscreenBtn">Fullscreen</button>
      </div>

      <div class="teams" id="teamsRow"></div>
    </header>

    <main>
      <div class="roundBanner">
        <div class="roundPill" id="roundPill"><strong>Round 1</strong></div>
        <div class="roundPill" id="modePill"><strong>Classic</strong></div>
        <div class="roundPill" id="timerPill"><strong>Timer:</strong> <span id="timerDefaultReadout">10</span>s</div>
        <div class="roundPill" id="safePill"><strong>SAFE:</strong> <span id="safeModeReadout">ON</span></div>
      </div>

      <div class="winner" id="winner"></div>

      <div class="boardWrap">
        <div class="board" id="board"></div>
      </div>
    </main>

    <div class="backdrop" id="backdrop"></div>

    <!-- Question Modal -->
    <div class="modal" id="questionModal" role="dialog" aria-modal="true" aria-label="Question">
      <div class="qa-top">
        <div class="pill" id="qaMetaLeft"><strong>—</strong></div>
        <div class="pill" id="qaMetaRight"><strong>—</strong></div>
        <div class="vis">
          <div class="pill" id="hostVisPill">HOST: <strong id="hostVisText">HIDDEN</strong></div>
          <div class="pill" id="projVisPill">PROJECTOR: <strong id="projVisText">HIDDEN</strong></div>
        </div>
      </div>

      <div class="question" id="questionText"></div>
      <div class="answer" id="answerText" aria-live="polite"></div>

      <div class="modal-controls">
        <div class="team-buttons" id="awardButtonsRow"></div>

        <div class="row-buttons">
          <button class="btn-gold" id="noTeamBtn">No Team</button>
          <button id="hostAnswerBtn">Show Answer (Host)</button>
          <button id="projAnswerBtn" title="SAFE MODE may require hold/confirm">Reveal Answer (Projector)</button>
          <button id="bothAnswerBtn">Reveal Both</button>
          <button id="pauseBtn">Pause</button>
          <button class="btn-danger" id="closeQuestionBtn">Close</button>
        </div>
      </div>

      <div class="timer" id="timer">10</div>
      <div class="time-overlay" id="timeOverlay">TIME</div>
    </div>

    <!-- Round splash -->
    <div class="splash" id="roundSplash" aria-label="Round splash">
      <div class="box">
        <div class="big" id="splashTitle">ROUND 1</div>
        <div class="small" id="splashSubtitle">Get ready.</div>
        <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
          <button class="btn-gold" id="startRoundBtn">Start Round</button>
        </div>
      </div>
    </div>

    <!-- Builder -->
    <div class="builder" id="builder">
      <div class="builderHead">
        <h2>Question Builder</h2>
        <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
          <button class="btn-gold" id="builderAddRoundBtn">Add Round</button>
          <button id="builderAddCategoryBtn">Add Category</button>
          <button id="builderCopyJsonBtn">Copy JSON</button>
          <button class="btn-danger" id="builderCloseBtn">Close</button>
        </div>
      </div>
      <div class="builderBody" id="builderBody"></div>
    </div>

    <!-- Slot manager modal -->
    <div class="modal" id="slotModal" role="dialog" aria-modal="true" aria-label="Save Slot Manager" style="height:min(62vh,560px);">
      <div class="qa-top" style="justify-content:space-between;">
        <div class="pill"><strong>SAVE SLOTS</strong></div>
        <div class="vis">
          <button class="btn-danger" id="closeSlotModalBtn">Close</button>
        </div>
      </div>

      <div class="slotModalBody">
        <div class="panel" style="margin-bottom:12px;">
          <h3>Create New Slot</h3>
          <div class="row">
            <div class="field">
              <label for="newSlotName">Slot name</label>
              <input id="newSlotName" type="text" placeholder="e.g., C Block — Modern Middle East (Day 2)" />
            </div>
            <button class="btn-gold" id="createSlotBtn">Create</button>
          </div>
          <div class="tiny" style="margin-top:8px;">Tip: slots are separate saved games. Switch slots to resume where you left off.</div>
        </div>

        <div class="panel" style="margin-bottom:12px;">
          <h3>Rename Current Slot</h3>
          <div class="row">
            <div class="field">
              <label for="renameSlotName">New name</label>
              <input id="renameSlotName" type="text" placeholder="Type a new name for the selected slot" />
            </div>
            <button id="renameSlotBtn">Rename</button>
          </div>
        </div>

        <div class="panel" style="margin-bottom:12px;">
          <h3>Duplicate Slot</h3>
          <div class="row">
            <div class="field">
              <label for="duplicateSlotName">New slot name</label>
              <input id="duplicateSlotName" type="text" placeholder="e.g., D Block — same game" />
            </div>
            <button id="duplicateSlotBtn">Duplicate</button>
          </div>
          <div class="tiny" style="margin-top:8px;">This copies the saved game from the current slot into a new slot (great for cloning C → D).</div>
        </div>

        <div class="panel">
          <h3>Danger Zone</h3>
          <div class="row">
            <button class="btn-danger" id="deleteSlotBtn">Delete This Slot</button>
          </div>
          <div class="tiny" style="margin-top:8px;">Deleting a slot deletes its saved game. This can’t be undone.</div>
        </div>
      </div>
    </div>
  </section>

  <script>
    /* =========================================================
       GEFFEN BOWL — Phase 4 + Slot Saves + Export/Import + Template
       - Save slots (named)
       - Export/Import current slot
       - Copy JSON template
    ========================================================== */

    // ----------------------------
    // Utilities
    // ----------------------------
    const qs = (sel) => document.querySelector(sel);
    const qsa = (sel) => Array.from(document.querySelectorAll(sel));

    function clampInt(n, fallback=0){
      const x = parseInt(String(n).replace(/[^\d-]/g,''), 10);
      return Number.isFinite(x) ? x : fallback;
    }

    function escapeHtml(str){
      return String(str)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'","&#039;");
    }

    function cssEscape(s){
      if (window.CSS && CSS.escape) return CSS.escape(s);
      return String(s).replace(/["\\]/g, '\\$&');
    }

    function nowId(){
      return Math.random().toString(36).slice(2,10);
    }

    function deepClone(o){
      return JSON.parse(JSON.stringify(o));
    }

    // ----------------------------
    // Projector detection + channel
    // ----------------------------
    const params = new URLSearchParams(location.search);
    const isProjectorView = params.get('view') === 'projector';
    if (isProjectorView) document.body.classList.add('projector');

    const CHANNEL_NAME = 'geffenbowl_channel_v1';
    let bc = null;
    try { bc = new BroadcastChannel(CHANNEL_NAME); } catch(e){ bc = null; }

    function sendToProjector(payload){
      if (!payload) return;
      if (bc) bc.postMessage(payload);
      if (projectorWin && !projectorWin.closed){
        try { projectorWin.postMessage(payload, '*'); } catch(e){}
      }
    }

    function onProjectorMessage(handler){
      if (bc) bc.onmessage = (e) => handler(e.data);
      window.addEventListener('message', (e) => handler(e.data));
    }

    // ----------------------------
    // Global state
    // ----------------------------
    const SAVE_KEY_BASE = 'geffen_bowl_save_v4';
    const SLOT_INDEX_KEY = `${SAVE_KEY_BASE}__slot_index_v1`;

    const defaultState = () => ({
      meta: { version: 4 },
      settings: {
        mode: 'classic',
        teamCount: 3,
        timerDefault: 10,
        autosave: true,
        projectorEnabled: true,
        safeMode: true,
        defaultRevealBoth: false,
        saveSlot: 'Default'
      },
      teams: [
        { id: 't1', name: 'Team 1', score: 0 },
        { id: 't2', name: 'Team 2', score: 0 },
        { id: 't3', name: 'Team 3', score: 0 }
      ],
      rounds: [
        { id: 'r1', title: 'Round 1', categories: {} }
      ],
      currentRoundIndex: 0,
      isDouble: false,
      activeTeamIndex: 0,
      currentPick: null, // { roundIndex, category, index }
      timer: { running: false, paused: false, timeLeft: 10 },
      projector: { connected: false }
    });

    let state = defaultState();

    // Host-only window handle
    let projectorWin = null;

    // Undo stack
    let undoStack = [];

    // ----------------------------
    // Slot helpers
    // ----------------------------
    function sanitizeSlotName(name){
      return String(name || '')
        .trim()
        .slice(0, 60)
        .replace(/[^\w\s\-—:()&.]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function readSlotIndex(){
      try{
        const raw = localStorage.getItem(SLOT_INDEX_KEY);
        if (!raw) return ['Default'];
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr) || !arr.length) return ['Default'];
        const uniq = [];
        for (const s of arr){
          const ss = sanitizeSlotName(s);
          if (ss && !uniq.includes(ss)) uniq.push(ss);
        }
        return uniq.length ? uniq : ['Default'];
      }catch(e){
        return ['Default'];
      }
    }

    function writeSlotIndex(slots){
      try{ localStorage.setItem(SLOT_INDEX_KEY, JSON.stringify(slots, null, 0)); }catch(e){}
    }

    function ensureSlotExists(slotName){
      const name = sanitizeSlotName(slotName) || 'Default';
      const slots = readSlotIndex();
      if (!slots.includes(name)){
        slots.push(name);
        writeSlotIndex(slots);
      }
      return name;
    }

    function getSaveKey(slotName){
      const slot = sanitizeSlotName(slotName) || 'Default';
      return `${SAVE_KEY_BASE}__${slot}`;
    }

    function currentSlot(){
      return sanitizeSlotName(state?.settings?.saveSlot) || 'Default';
    }

    function slotHasSave(slotName){
      try{ return !!localStorage.getItem(getSaveKey(slotName)); }catch(e){ return false; }
    }

    function renderSlotSelect(selected){
      const sel = qs('#saveSlotSelect');
      if (!sel) return;

      const slots = readSlotIndex();
      const pick = sanitizeSlotName(selected) || slots[0] || 'Default';

      sel.innerHTML = slots.map(s => {
        const mark = slotHasSave(s) ? ' •' : '';
        return `<option value="${escapeHtml(s)}">${escapeHtml(s)}${mark}</option>`;
      }).join('');

      sel.value = slots.includes(pick) ? pick : (slots[0] || 'Default');
    }

    function setSlot(slotName, {loadIfExists=true} = {}){
      const slot = ensureSlotExists(slotName);
      state.settings.saveSlot = slot;

      if (loadIfExists && loadStateForSlot(slot)){
        state.settings.saveSlot = slot;
      } else {
        const prevSettings = state.settings;
        state = defaultState();
        state.settings = { ...state.settings, ...prevSettings, saveSlot: slot };
        undoStack = [];
      }

      renderSlotSelect(slot);

      // Update title placeholder hint
      const ph = slotHasSave(slot)
        ? `Saved game detected in "${slot}". Click Start to resume, or paste JSON to overwrite.`
        : `No saved game in "${slot}" yet. Paste JSON or use the Builder.`;
      const ta = qs('#jsonInputTitle');
      if (ta) ta.placeholder = ph;

      // If we're already in game screen, refresh UI
      if (!isProjectorView && qs('#gameScreen').style.display === 'block'){
        renderHeaderPills();
        renderTeams();
        renderBoard();
        setWinnerBanner();
        broadcastState();
      }
      saveState(); // respects autosave toggle
    }

    // ----------------------------
    // JSON format support
    // ----------------------------
    function normalizeQuestion(q){
      return {
        question: String(q?.question ?? ''),
        answer: String(q?.answer ?? ''),
        points: clampInt(q?.points ?? 0, 0),
        _state: q?._state || 'unplayed', // unplayed|answered|missed|expired
        _hostShown: !!q?._hostShown,
        _projShown: !!q?._projShown
      };
    }

    function normalizeCategories(obj){
      const out = {};
      for (const cat of Object.keys(obj || {})){
        const arr = Array.isArray(obj[cat]) ? obj[cat] : [];
        out[String(cat)] = arr.map(normalizeQuestion);
      }
      return out;
    }

function parseAnyJson(raw){
  const parsed = JSON.parse(raw);

  // ---------- New format ----------
  // {
  //   "teams":[{"name":"A","score":0}, ...] (optional),
  //   "rounds":[{"title":"Round 1","categories":{...}}, ...]
  // }
  if (parsed && typeof parsed === 'object' && Array.isArray(parsed.rounds)){
    const rounds = parsed.rounds.map((r, i) => ({
      id: r.id || `r${i+1}_${nowId()}`,
      title: String(r.title ?? `Round ${i+1}`),
      categories: normalizeCategories(r.categories || {})
    }));

    const teams = Array.isArray(parsed.teams)
      ? parsed.teams.slice(0,6).map((t, i) => ({
          id: t.id || `t${i+1}_${nowId()}`,
          name: String(t.name ?? `Team ${i+1}`),
          score: clampInt(t.score ?? 0, 0)
        }))
      : null;

    return { rounds, teams };
  }

  // ---------- Round-map format (your template) ----------
  // {
  //   "Round 1": { "Category": [ ... ], ... },
  //   "Round 2": { ... }
  // }
  if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)){
    const keys = Object.keys(parsed);

    // treat as round-map if EVERY top-level key looks like "Round X"
    const roundKeyRegex = /^round\s*\d+/i;
    const looksLikeRoundMap =
      keys.length > 0 &&
      keys.every(k => roundKeyRegex.test(String(k).trim())) &&
      keys.every(k => parsed[k] && typeof parsed[k] === 'object' && !Array.isArray(parsed[k]));

    if (looksLikeRoundMap){
      // sort rounds by their numeric index if present
      const sortedKeys = keys.slice().sort((a, b) => {
        const na = parseInt(String(a).match(/\d+/)?.[0] || '0', 10);
        const nb = parseInt(String(b).match(/\d+/)?.[0] || '0', 10);
        return na - nb;
      });

      const rounds = sortedKeys.map((rk, i) => ({
        id: `r${i+1}_${nowId()}`,
        title: String(rk),
        categories: normalizeCategories(parsed[rk] || {})
      }));

      return { rounds, teams: null };
    }
  }

  // ---------- Old format (single round) ----------
  // { "Category":[{question,answer,points},...], ... }
  if (parsed && typeof parsed === 'object'){
    const categories = normalizeCategories(parsed);
    return {
      rounds: [{ id: 'r1_'+nowId(), title: 'Round 1', categories }],
      teams: null
    };
  }

  throw new Error('Unsupported JSON shape.');
}
    function exportJson(){
      return JSON.stringify({
        teams: state.teams.map(t => ({ name: t.name, score: t.score })),
        rounds: state.rounds.map(r => ({
          title: r.title,
          categories: Object.fromEntries(Object.entries(r.categories).map(([cat, arr]) => [
            cat,
            (arr || []).map(q => ({ question: q.question, answer: q.answer, points: q.points }))
          ]))
        }))
      }, null, 2);
    }
function jsonTemplate(){
  return JSON.stringify({
    "rounds": [
      {
        "title": "Round 1",
        "categories": {
          "Category 1": [
            { "question": "Sample Question 1", "answer": "Sample Answer 1", "points": 100 },
            { "question": "Sample Question 2", "answer": "Sample Answer 2", "points": 200 },
            { "question": "Sample Question 3", "answer": "Sample Answer 3", "points": 300 },
            { "question": "Sample Question 4", "answer": "Sample Answer 4", "points": 400 },
            { "question": "Sample Question 5", "answer": "Sample Answer 5", "points": 500 }
          ],
          "Category 2": [
            { "question": "Sample Question 1", "answer": "Sample Answer 1", "points": 100 },
            { "question": "Sample Question 2", "answer": "Sample Answer 2", "points": 200 },
            { "question": "Sample Question 3", "answer": "Sample Answer 3", "points": 300 },
            { "question": "Sample Question 4", "answer": "Sample Answer 4", "points": 400 },
            { "question": "Sample Question 5", "answer": "Sample Answer 5", "points": 500 }
          ]
        }
      },
      {
        "title": "Round 2",
        "categories": {
          "Category 1": [
            { "question": "Sample Question 1", "answer": "Sample Answer 1", "points": 100 }
          ]
        }
      }
    ]
  }, null, 2);
}
    // ----------------------------
    // Persistence (slot-based)
    // ----------------------------
    function saveState(){
      if (!state.settings.autosave) return;
      try{
        ensureSlotExists(currentSlot());
        const payload = { state, undoStack };
        localStorage.setItem(getSaveKey(currentSlot()), JSON.stringify(payload));
      }catch(e){}
    }

    function loadStateForSlot(slotName){
      try{
        const raw = localStorage.getItem(getSaveKey(slotName));
        if (!raw) return false;
        const payload = JSON.parse(raw);
        if (!payload?.state) return false;
        state = payload.state;
        undoStack = payload.undoStack || [];
        return true;
      }catch(e){
        return false;
      }
    }

    function loadState(){
      // Loads the state for state.settings.saveSlot (or Default)
      return loadStateForSlot(currentSlot());
    }

    function clearSaved(){
      try{ localStorage.removeItem(getSaveKey(currentSlot())); }catch(e){}
    }

    // ----------------------------
    // Export / Import save (current slot)
    // ----------------------------
    function exportSaveToFile(){
      const slot = currentSlot();
      const key = getSaveKey(slot);
      let raw = null;
      try{ raw = localStorage.getItem(key); }catch(e){ raw = null; }

      if (!raw){
        alert(`No saved game found in slot "${slot}".`);
        return;
      }

      const blob = new Blob([raw], { type: 'application/json' });
      const a = document.createElement('a');
      const safe = slot.replace(/[^\w\-]+/g,'_').slice(0, 40) || 'slot';
      a.href = URL.createObjectURL(blob);
      a.download = `geffen_bowl_save__${safe}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 250);
    }

    function importSaveFromFile(file){
      const reader = new FileReader();
      reader.onload = () => {
        try{
          const txt = String(reader.result || '');
          const payload = JSON.parse(txt);

          if (!payload?.state || !payload.state?.meta){
            throw new Error('Not a Geffen Bowl save file.');
          }

          // Force this imported state into current slot
          const slot = currentSlot();
          payload.state.settings = payload.state.settings || {};
          payload.state.settings.saveSlot = slot;

          // Store it
          localStorage.setItem(getSaveKey(slot), JSON.stringify(payload));

          // Load into memory immediately
          loadStateForSlot(slot);

          alert(`Imported save into slot "${slot}".`);
          renderSlotSelect(slot);
          qs('#jsonInputTitle').placeholder = `Saved game detected in "${slot}". Click Start to resume, or paste JSON to overwrite.`;
        }catch(e){
          alert('Import failed. Please select a valid exported save file.');
        }
      };
      reader.readAsText(file);
    }

    // ----------------------------
    // Mode presets
    // ----------------------------
    function applyModePreset(mode){
      state.settings.mode = mode;

      if (mode === 'classic'){
        state.settings.timerDefault = clampInt(state.settings.timerDefault, 10) || 10;
        state.rounds = [state.rounds[0] || { id:'r1_'+nowId(), title:'Round 1', categories:{} }];
        state.rounds[0].title = 'Round 1';
        state.currentRoundIndex = 0;
      }
      if (mode === 'tworound'){
        state.settings.timerDefault = clampInt(state.settings.timerDefault, 10) || 10;
        const r1 = state.rounds[0] || { id:'r1_'+nowId(), title:'Round 1', categories:{} };
        const r2 = state.rounds[1] || { id:'r2_'+nowId(), title:'Round 2', categories:{} };
        r1.title = 'Round 1';
        r2.title = 'Round 2';
        state.rounds = [r1, r2];
        state.currentRoundIndex = 0;
      }
      if (mode === 'lightning'){
        state.settings.timerDefault = 7;
        const r1 = state.rounds[0] || { id:'r1_'+nowId(), title:'Round 1', categories:{} };
        r1.title = 'Round 1';
        state.rounds = [r1];
        state.currentRoundIndex = 0;
      }
      if (mode === 'tournament'){
        state.settings.timerDefault = clampInt(state.settings.timerDefault, 10) || 10;
        const r1 = state.rounds[0] || { id:'r1_'+nowId(), title:'Round 1', categories:{} };
        const r2 = state.rounds[1] || { id:'r2_'+nowId(), title:'Round 2', categories:{} };
        r1.title = 'Round 1';
        r2.title = 'Round 2';
        state.rounds = [r1, r2];
        state.currentRoundIndex = 0;
      }

      state.timer.timeLeft = state.settings.timerDefault;
      state.timer.running = false;
      state.timer.paused = false;
      state.isDouble = false;
    }

    // ----------------------------
    // Teams
    // ----------------------------
    function setTeamCount(n){
      const count = Math.max(2, Math.min(6, clampInt(n, 3)));
      state.settings.teamCount = count;

      const next = [];
      for (let i=0; i<count; i++){
        const existing = state.teams[i];
        next.push(existing || { id:`t${i+1}_${nowId()}`, name:`Team ${i+1}`, score:0 });
      }
      state.teams = next;
      state.activeTeamIndex = Math.min(state.activeTeamIndex, state.teams.length - 1);
    }

    // ----------------------------
    // Rendering
    // ----------------------------
    function showTitle(){
      qs('#titleScreen').style.display = 'flex';
      qs('#gameScreen').style.display = 'none';
    }

    function showGame(){
      qs('#titleScreen').style.display = 'none';
      qs('#gameScreen').style.display = 'block';
    }

    function renderHeaderPills(){
      qs('#modePill strong').innerText = ({
        classic:'Classic',
        tworound:'Two-Round',
        lightning:'Lightning',
        tournament:'Tournament'
      })[state.settings.mode] || 'Mode';

      qs('#timerDefaultReadout').innerText = String(state.settings.timerDefault);
      qs('#safeModeReadout').innerText = state.settings.safeMode ? 'ON' : 'OFF';

      const round = state.rounds[state.currentRoundIndex];
      qs('#roundPill strong').innerText = round?.title || `Round ${state.currentRoundIndex+1}`;

      qs('#toggleDoubleBtn').innerText = `Double: ${state.isDouble ? 'ON' : 'OFF'}`;
      const board = qs('#board');
      if (state.isDouble) board.classList.add('double-on');
      else board.classList.remove('double-on');

      qs('#safePill').style.borderColor = state.settings.safeMode ? 'rgba(255,224,102,.30)' : 'rgba(255,255,255,.10)';
    }

    function renderTeams(){
      const row = qs('#teamsRow');
      row.innerHTML = '';

      state.teams.forEach((t, idx) => {
        const el = document.createElement('div');
        el.className = 'team' + (idx === state.activeTeamIndex ? ' active' : '');
        el.dataset.teamIndex = String(idx);

        el.innerHTML = `
          <div class="name editable" contenteditable="${isProjectorView ? 'false':'true'}" data-type="teamName">${escapeHtml(t.name)}</div>
          <div class="score editable" contenteditable="${isProjectorView ? 'false':'true'}" data-type="teamScore">${escapeHtml(String(t.score))}</div>
        `;

        if (!isProjectorView){
          el.addEventListener('click', () => {
            state.activeTeamIndex = idx;
            renderTeams();
            saveState();
            broadcastState();
          });

          const nameEl = el.querySelector('[data-type="teamName"]');
          const scoreEl = el.querySelector('[data-type="teamScore"]');

          nameEl.addEventListener('keydown', preventEnterKey);
          nameEl.addEventListener('blur', () => {
            t.name = nameEl.innerText.replace(/\s+/g,' ').trim() || `Team ${idx+1}`;
            renderTeams();
            setWinnerBanner();
            saveState();
            broadcastState();
          });

          scoreEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter'){ e.preventDefault(); scoreEl.blur(); }
          });
          scoreEl.addEventListener('blur', () => {
            t.score = clampInt(scoreEl.innerText, 0);
            renderTeams();
            setWinnerBanner();
            saveState();
            broadcastState();
          });
        }

        row.appendChild(el);
      });
    }

    function getCurrentRound(){
      return state.rounds[state.currentRoundIndex] || state.rounds[0];
    }

    function getCategories(){
      const r = getCurrentRound();
      return Object.keys(r?.categories || {});
    }

    function maxRows(){
      const r = getCurrentRound();
      const cats = getCategories();
      if (!cats.length) return 0;
      return Math.max(...cats.map(c => (r.categories[c] || []).length), 0);
    }

    function applyCellStateClass(cell, st){
      cell.classList.remove('answered','missed','expired','clickable');
      if (st === 'answered') cell.classList.add('answered');
      if (st === 'missed') cell.classList.add('missed');
      if (st === 'expired') cell.classList.add('expired');
      if (st === 'unplayed') cell.classList.add('clickable');
    }

    function renderBoard(){
      const board = qs('#board');
      board.innerHTML = '';

      const r = getCurrentRound();
      const cats = getCategories();
      if (!cats.length){
        board.innerHTML = `
          <div class="panel" style="max-width:760px; margin: 0 auto; text-align:center;">
            <h3 style="margin:0 0 10px; letter-spacing:.14em; text-transform:uppercase; color: var(--gold);">No questions loaded</h3>
            <div class="tiny">Open the Question Builder, or paste JSON on the title screen.</div>
          </div>
        `;
        return;
      }

      const rows = maxRows();
      board.style.gridTemplateColumns = `repeat(${cats.length}, 1fr)`;
      board.style.gridTemplateRows = `repeat(${rows + 1}, auto)`;

      for (const cat of cats){
        const cell = document.createElement('div');
        cell.className = 'cell category';
        cell.innerHTML = `<div class="cat">${escapeHtml(cat)}</div>`;
        board.appendChild(cell);
      }

      for (let i=0; i<rows; i++){
        for (const cat of cats){
          const q = (r.categories[cat] || [])[i];
          const cell = document.createElement('div');
          cell.className = 'cell';

          if (q){
            const st = q._state || 'unplayed';
            const value = q.points * (state.isDouble ? 2 : 1);

            cell.dataset.category = cat;
            cell.dataset.index = String(i);
            cell.dataset.state = st;

            cell.innerHTML = `<div class="value">${escapeHtml(String(value))}</div>`;
            applyCellStateClass(cell, st);

            if (!isProjectorView && st === 'unplayed'){
              cell.onclick = () => selectQuestion(state.currentRoundIndex, cat, i);
            }
          } else {
            cell.style.opacity = '.12';
            cell.style.borderColor = 'rgba(255,255,255,.06)';
            cell.style.filter = 'saturate(.2)';
          }

          board.appendChild(cell);
        }
      }

      renderHeaderPills();
    }

    function setWinnerBanner(){
      const winnerEl = qs('#winner');
      const max = Math.max(...state.teams.map(t => t.score), 0);
      const winners = state.teams.filter(t => t.score === max).map(t => t.name || 'Team');

      if (!getCategories().length){
        winnerEl.style.display = 'none';
        return;
      }

      winnerEl.style.display = 'block';
      winnerEl.innerText = (winners.length === 1)
        ? `Leading: ${winners[0]} (${max})`
        : `Tie: ${winners.join(' & ')} (${max})`;
    }

    // ----------------------------
    // Modal + timer
    // ----------------------------
    let timerInterval = null;

    function showBackdrop(){ qs('#backdrop').classList.add('show'); }
    function hideBackdrop(){ qs('#backdrop').classList.remove('show'); }

    function showModal(){
      showBackdrop();
      qs('#questionModal').classList.add('show');
      qs('#questionModal').style.display = 'block';
    }
    function hideModal(){
      qs('#questionModal').classList.remove('show');
      qs('#questionModal').style.display = 'none';
      hideBackdrop();
    }

    function clearTimer(){
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      state.timer.running = false;
      state.timer.paused = false;
      qs('#pauseBtn').innerText = 'Pause';
      qs('#timer').classList.remove('low');
      qs('#timeOverlay').classList.remove('show');
    }

    function startTimer(){
      clearTimer();
      state.timer.running = true;
      state.timer.paused = false;
      timerInterval = setInterval(() => {
        if (state.timer.paused) return;

        if (state.timer.timeLeft > 0){
          state.timer.timeLeft--;
          renderTimerUI();
          broadcastState({ timerTick: true });
          saveState();

          if (state.timer.timeLeft === 0){
            qs('#timeOverlay').classList.add('show');
            markExpiredIfStillUnplayed();
            clearTimer();
            broadcastState();
            saveState();
          }
        }
      }, 1000);
    }

    function renderTimerUI(){
      qs('#timer').innerText = String(state.timer.timeLeft);
      qs('#timer').classList.toggle('low', state.timer.timeLeft <= 5);
    }

    function preventEnterKey(e){
      if (e.key === 'Enter'){
        e.preventDefault();
        document.execCommand('insertText', false, ' ');
      }
    }

    function currentQuestionObj(){
      if (!state.currentPick) return null;
      const { roundIndex, category, index } = state.currentPick;
      const r = state.rounds[roundIndex];
      const q = r?.categories?.[category]?.[index];
      return q || null;
    }

    function updateVisibilityPills(){
      const q = currentQuestionObj();
      const hostShown = !!q?._hostShown;
      const projShown = !!q?._projShown;

      qs('#hostVisText').innerText = hostShown ? 'SHOWN' : 'HIDDEN';
      qs('#projVisText').innerText = projShown ? 'SHOWN' : 'HIDDEN';

      const hostPill = qs('#hostVisPill');
      const projPill = qs('#projVisPill');

      hostPill.classList.toggle('ok', hostShown);
      hostPill.classList.toggle('no', !hostShown);

      projPill.classList.toggle('ok', projShown);
      projPill.classList.toggle('no', !projShown);
    }

    function renderAwardButtons(){
      const row = qs('#awardButtonsRow');
      row.innerHTML = '';

      state.teams.forEach((t, idx) => {
        const b = document.createElement('button');
        b.className = 'team-button primary';
        b.innerText = t.name || `Team ${idx+1}`;
        b.addEventListener('click', () => awardToTeam(idx));
        row.appendChild(b);
      });
    }

    function selectQuestion(roundIndex, category, index){
      const r = state.rounds[roundIndex];
      const q = r?.categories?.[category]?.[index];
      if (!q) return;
      if ((q._state || 'unplayed') !== 'unplayed') return;

      state.currentPick = { roundIndex, category, index };

      qs('#qaMetaLeft').innerHTML = `<strong>${escapeHtml(category)}</strong>`;
      const pts = q.points * (state.isDouble ? 2 : 1);
      qs('#qaMetaRight').innerHTML = `<strong>${pts} pts</strong>`;

      qs('#questionText').innerText = q.question;
      qs('#answerText').innerText = '';
      qs('#answerText').classList.remove('revealed');

      state.timer.timeLeft = clampInt(state.settings.timerDefault, 10);
      renderTimerUI();
      qs('#timeOverlay').classList.remove('show');

      updateVisibilityPills();
      renderAwardButtons();

      showModal();
      startTimer();

      broadcastState();
      saveState();
    }

    function pauseTimer(){
      if (!state.currentPick) return;
      state.timer.paused = !state.timer.paused;
      qs('#pauseBtn').innerText = state.timer.paused ? 'Resume' : 'Pause';
      broadcastState();
      saveState();
    }

    function showAnswerHost(toggle=true){
      const q = currentQuestionObj();
      if (!q) return;

      q._hostShown = toggle ? !q._hostShown : true;

      if (q._hostShown){
        qs('#answerText').innerText = q.answer;
        qs('#answerText').classList.add('revealed');
      } else {
        qs('#answerText').innerText = '';
        qs('#answerText').classList.remove('revealed');
      }

      updateVisibilityPills();
      broadcastState();
      saveState();
    }

    function showAnswerProjector(forceOn=null){
      const q = currentQuestionObj();
      if (!q) return;

      const target = (forceOn === null) ? !q._projShown : !!forceOn;
      q._projShown = target;

      updateVisibilityPills();
      broadcastState();
      saveState();
    }

    function showAnswerBoth(){
      const q = currentQuestionObj();
      if (!q) return;

      q._hostShown = true;
      qs('#answerText').innerText = q.answer;
      qs('#answerText').classList.add('revealed');

      q._projShown = true;

      updateVisibilityPills();
      broadcastState();
      saveState();
    }

    function markExpiredIfStillUnplayed(){
      const q = currentQuestionObj();
      if (!q) return;
      if ((q._state || 'unplayed') !== 'unplayed') return;

      const { roundIndex, category, index } = state.currentPick;
      const prevState = q._state || 'unplayed';

      q._state = 'expired';

          undoStack.push({
        type:'expired',
        roundIndex, category, index,
        prevState
      });

      renderBoard();

      if (isCurrentRoundComplete()){
        setTimeout(() => {
          nextRoundIfAvailable();
        }, 600);
      }

      saveState();
    }

    function closeQuestion(){
      clearTimer();
      hideModal();
      state.currentPick = null;
      broadcastState();
      saveState();
    }

    function pointsForCurrent(){
      const q = currentQuestionObj();
      if (!q) return 0;
      return q.points * (state.isDouble ? 2 : 1);
    }

    function awardToTeam(teamIndex){
      const q = currentQuestionObj();
      if (!q) return;

      const { roundIndex, category, index } = state.currentPick;
      const prevState = q._state || 'unplayed';
      if (prevState !== 'unplayed') return;

      const pts = pointsForCurrent();
      const prevScores = state.teams.map(t => t.score);

      state.teams[teamIndex].score += pts;
      state.activeTeamIndex = teamIndex;

      q._state = 'answered';
      q._hostShown = true;
      qs('#answerText').innerText = q.answer;
      qs('#answerText').classList.add('revealed');

      undoStack.push({
        type:'award',
        roundIndex, category, index,
        prevState,
        teamIndex,
        pointsDelta: pts,
        prevScores
      });

      renderTeams();
      setWinnerBanner();
      renderBoard();
      updateVisibilityPills();
      clearTimer();

      broadcastState();

      if (isCurrentRoundComplete()){
        setTimeout(() => {
          nextRoundIfAvailable();
        }, 600);
      }

      saveState();
    }

    function noTeamCorrect(){
      const q = currentQuestionObj();
      if (!q) return;

      const { roundIndex, category, index } = state.currentPick;
      const prevState = q._state || 'unplayed';
      if (prevState !== 'unplayed') return;

      undoStack.push({
        type:'noTeam',
        roundIndex, category, index,
        prevState
      });

      q._state = 'missed';
      q._hostShown = true;
      qs('#answerText').innerText = q.answer;
      qs('#answerText').classList.add('revealed');

      renderBoard();
      updateVisibilityPills();
      clearTimer();

      broadcastState();

      if (isCurrentRoundComplete()){
        setTimeout(() => {
          nextRoundIfAvailable();
        }, 600);
      }

      saveState();
    }

    function undoLast(){
      if (!undoStack.length){
        alert('No actions to undo.');
        return;
      }

      const last = undoStack.pop();
      const r = state.rounds[last.roundIndex];
      const q = r?.categories?.[last.category]?.[last.index];
      if (!q) return;

      q._state = last.prevState || 'unplayed';

      if (last.type === 'award' && Array.isArray(last.prevScores)){
        state.teams.forEach((t, i) => t.score = last.prevScores[i] ?? t.score);
      }      renderTeams();
      setWinnerBanner();
      renderBoard();

      broadcastState();
      saveState();
    }

    function toggleDouble(){
      state.isDouble = !state.isDouble;
      renderHeaderPills();
      renderBoard();
      broadcastState();
      saveState();
    }

    // ----------------------------
    // Rounds
    // ----------------------------
  function isCurrentRoundComplete(){
const r = getCurrentRound();
if (!r) return false;

return Object.values(r.categories || {})
.flat()
.every(q => (q._state || 'unplayed') !== 'unplayed');
}
  function showRoundSplash(){
      const r = getCurrentRound();
      qs('#splashTitle').innerText = (r?.title || `Round ${state.currentRoundIndex+1}`).toUpperCase();
      qs('#splashSubtitle').innerText = 'Get ready.';
      qs('#roundSplash').classList.add('show');
      broadcastState({ splash: true });
    }

    function hideRoundSplash(){
      qs('#roundSplash').classList.remove('show');
      broadcastState({ splash: false });
    }

    function startRound(){
      hideRoundSplash();
      renderBoard();
      broadcastState();
      saveState();
    }

    function nextRoundIfAvailable(){
      if (state.currentRoundIndex < state.rounds.length - 1){
        state.currentRoundIndex++;
        state.isDouble = (state.settings.mode === 'tworound' || state.settings.mode === 'tournament');
        renderHeaderPills();
        renderBoard();
        showRoundSplash();
        saveState();
        broadcastState();
      } else {
        alert('No more rounds configured.');
      }
    }

    // ----------------------------
    // Builder
    // ----------------------------
    function ensureSomeQuestionsExist(){
      const r = getCurrentRound();
      if (!Object.keys(r.categories).length){
        r.categories['Category 1'] = [
          normalizeQuestion({question:'Sample Q1', answer:'Sample A1', points:100}),
          normalizeQuestion({question:'Sample Q2', answer:'Sample A2', points:200}),
          normalizeQuestion({question:'Sample Q3', answer:'Sample A3', points:300})
        ];
      }
    }

    function openBuilder(){
      if (isProjectorView) return;

      ensureSomeQuestionsExist();
      renderBuilder();
      qs('#builder').classList.add('show');
      qs('#backdrop').classList.add('show');
    }

    function closeBuilder(){
      qs('#builder').classList.remove('show');
      qs('#backdrop').classList.remove('show');
      renderBoard();
      saveState();
      broadcastState();
    }

    function addRound(){
      const n = state.rounds.length + 1;
      state.rounds.push({ id: `r${n}_${nowId()}`, title:`Round ${n}`, categories:{} });
      renderBuilder();
      saveState();
      broadcastState();
    }

    function addCategory(){
      const r = getCurrentRound();
      const base = 'New Category';
      let name = base;
      let i = 2;
      while (r.categories[name]){ name = `${base} ${i++}`; }
      r.categories[name] = [
        normalizeQuestion({question:'New question', answer:'New answer', points:100})
      ];
      renderBuilder();
      saveState();
      broadcastState();
    }

    function addQuestion(cat){
      const r = getCurrentRound();
      r.categories[cat] = r.categories[cat] || [];
      r.categories[cat].push(normalizeQuestion({question:'New question', answer:'New answer', points:100}));
      renderBuilder();
      saveState();
      broadcastState();
    }

    function removeCategory(cat){
      const r = getCurrentRound();
      if (!confirm(`Delete category "${cat}"?`)) return;
      delete r.categories[cat];
      renderBuilder();
      saveState();
      broadcastState();
    }

    function removeQuestion(cat, idx){
      const r = getCurrentRound();
      if (!confirm('Delete this question?')) return;
      r.categories[cat].splice(idx, 1);
      renderBuilder();
      saveState();
      broadcastState();
    }

    function renameCategory(oldName, newName){
      const r = getCurrentRound();
      const nn = String(newName || '').trim();
      if (!nn || nn === oldName) return;
      if (r.categories[nn]){
        alert('That category name already exists.');
        return;
      }
      r.categories[nn] = r.categories[oldName];
      delete r.categories[oldName];
      renderBuilder();
      saveState();
      broadcastState();
    }

    function renderBuilder(){
      const body = qs('#builderBody');
      body.innerHTML = '';

      const roundPanel = document.createElement('div');
      roundPanel.className = 'catBlock';
      roundPanel.innerHTML = `
        <div class="catTop">
          <div class="catName">Editing Round</div>
          <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
            <select id="builderRoundSelect" style="min-width:220px;">
              ${state.rounds.map((r,i) => `<option value="${i}" ${i===state.currentRoundIndex?'selected':''}>${escapeHtml(r.title)}</option>`).join('')}
            </select>
            <button id="builderNextRoundBtn">Next Round</button>
          </div>
        </div>
        <div class="tiny">Tip: keep category names short for cleaner projector layout.</div>
      `;
      body.appendChild(roundPanel);

      const roundSelect = roundPanel.querySelector('#builderRoundSelect');
      roundSelect.addEventListener('change', () => {
        state.currentRoundIndex = clampInt(roundSelect.value, 0);
        renderBuilder();
        renderHeaderPills();
        saveState();
        broadcastState();
      });

      roundPanel.querySelector('#builderNextRoundBtn').addEventListener('click', () => nextRoundIfAvailable());

      const r = getCurrentRound();
      const cats = Object.keys(r.categories || {});
      if (!cats.length){
        const empty = document.createElement('div');
        empty.className = 'catBlock';
        empty.innerHTML = `<div class="tiny">No categories yet. Click <strong>Add Category</strong>.</div>`;
        body.appendChild(empty);
        return;
      }

      for (const cat of cats){
        const block = document.createElement('div');
        block.className = 'catBlock';

        block.innerHTML = `
          <div class="catTop">
            <div>
              <div class="catName">Category</div>
              <input type="text" value="${escapeHtml(cat)}" data-cat-rename="${escapeHtml(cat)}" />
            </div>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button class="btn-gold" data-add-q="${escapeHtml(cat)}">Add Question</button>
              <button class="btn-danger" data-del-cat="${escapeHtml(cat)}">Delete Category</button>
            </div>
          </div>
          <div class="hr"></div>
          <div class="tiny" style="margin-bottom:10px;">Questions</div>
          <div data-qwrap="${escapeHtml(cat)}"></div>
        `;

        body.appendChild(block);

        const renameInput = block.querySelector('input[type="text"]');
        renameInput.addEventListener('blur', () => {
          renameCategory(cat, renameInput.value);
        });

        block.querySelector(`[data-add-q="${cssEscape(cat)}"]`)?.addEventListener('click', () => addQuestion(cat));
        block.querySelector(`[data-del-cat="${cssEscape(cat)}"]`)?.addEventListener('click', () => removeCategory(cat));

        const wrap = block.querySelector(`[data-qwrap="${cssEscape(cat)}"]`);
        (r.categories[cat] || []).forEach((q, idx) => {
          const row = document.createElement('div');
          row.className = 'qRow';

          row.innerHTML = `
            <div class="qBox">
              <div class="mini">Question</div>
              <input type="text" value="${escapeHtml(q.question)}" data-q="${escapeHtml(cat)}" data-i="${idx}" data-field="question" />
            </div>
            <div class="qBox">
              <div class="mini">Answer</div>
              <input type="text" value="${escapeHtml(q.answer)}" data-q="${escapeHtml(cat)}" data-i="${idx}" data-field="answer" />
            </div>
            <div class="qBox">
              <div class="mini">Points</div>
              <input type="number" min="0" step="50" value="${escapeHtml(String(q.points))}" data-q="${escapeHtml(cat)}" data-i="${idx}" data-field="points" />
            </div>
            <div class="qBox">
              <div class="mini">Actions</div>
              <button class="btn-danger" data-del-q="${escapeHtml(cat)}" data-di="${idx}">Delete</button>
            </div>
          `;

          wrap.appendChild(row);

          row.querySelectorAll('input').forEach(inp => {
            inp.addEventListener('input', () => {
              const c = inp.getAttribute('data-q');
              const i = clampInt(inp.getAttribute('data-i'), -1);
              const f = inp.getAttribute('data-field');
              const qq = r.categories[c]?.[i];
              if (!qq) return;
              if (f === 'question') qq.question = inp.value;
              if (f === 'answer') qq.answer = inp.value;
              if (f === 'points') qq.points = clampInt(inp.value, 0);
              saveState();
              broadcastState();
              renderBoard();
            });
          });

          row.querySelector(`[data-del-q="${cssEscape(cat)}"][data-di="${idx}"]`)?.addEventListener('click', () => removeQuestion(cat, idx));
        });
      }
    }

    // ----------------------------
    // Projector window rendering
    // ----------------------------
    function renderProjectorStatus(){
      if (!isProjectorView) return;

      const dot = qs('#projStatusDot');
      const hint = qs('#projHint');

      if (!dot || !hint) return;

      dot.classList.toggle('ok', state.projector.connected);
      hint.style.display = 'inline-block';
      hint.textContent = state.projector.connected ? 'PROJECTOR CONNECTED' : 'WAITING FOR HOST';
    }

    function projectorRenderModalFromState(){
      if (!isProjectorView) return;

      const pick = state.currentPick;
      if (!pick){
        hideModal();
        return;
      }

      const q = currentQuestionObj();
      if (!q){
        hideModal();
        return;
      }

      qs('#qaMetaLeft').innerHTML = `<strong>${escapeHtml(pick.category)}</strong>`;
      const pts = q.points * (state.isDouble ? 2 : 1);
      qs('#qaMetaRight').innerHTML = `<strong>${pts} pts</strong>`;

      qs('#questionText').innerText = q.question;

      if (q._projShown){
        qs('#answerText').innerText = q.answer;
        qs('#answerText').classList.add('revealed');
      } else {
        qs('#answerText').innerText = '';
        qs('#answerText').classList.remove('revealed');
      }

      renderTimerUI();
      qs('#timeOverlay').classList.toggle('show', state.timer.timeLeft === 0);

      showModal();
    }

    // ----------------------------
    // Broadcast / sync
    // ----------------------------
    function broadcastState(extra={}){
      if (isProjectorView) return;
      if (!state.settings.projectorEnabled) return;

      sendToProjector({
        type:'STATE',
        state: deepClone(state),
        extra
      });
    }

    function handleIncoming(payload){
      if (!payload || typeof payload !== 'object') return;

      if (payload.type === 'PING' && !isProjectorView){
        state.projector.connected = true;
        saveState();
        renderProjectorConnectedUI(true);
        broadcastState({ pingReply:true });
        return;
      }

      if (payload.type === 'STATE' && isProjectorView){
        state = payload.state;
        state.projector.connected = true;
        renderProjectorStatus();
        renderHeaderPills();
        renderTeams();
        renderBoard();
        setWinnerBanner();
        projectorRenderModalFromState();

        if (payload.extra && 'splash' in payload.extra){
          qs('#roundSplash').classList.toggle('show', !!payload.extra.splash);
          qs('#splashTitle').innerText = (getCurrentRound()?.title || '').toUpperCase();
        }
        return;
      }
    }

    function renderProjectorConnectedUI(connected){
      if (isProjectorView) return;
      const hint = qs('#projHint');
      if (!hint) return;
      hint.style.display = connected ? 'inline-block' : 'none';
      hint.textContent = connected ? 'PROJECTOR CONNECTED' : '';
    }

    // ----------------------------
    // Title -> Start game
    // ----------------------------
    function titleToGame(){
      showGame();
      renderHeaderPills();
      renderTeams();
      renderBoard();
      setWinnerBanner();
      showRoundSplash();
      saveState();
      broadcastState();
    }

    function loadQuestionsFromTitleTextarea(){
      const raw = qs('#jsonInputTitle').value.trim();
      if (!raw) return false;

      try{
        const parsed = parseAnyJson(raw);
        state.rounds = parsed.rounds;

        state.rounds.forEach(r => {
          for (const cat of Object.keys(r.categories || {})){
            r.categories[cat] = (r.categories[cat] || []).map(qq => ({
              ...normalizeQuestion(qq),
              _state: 'unplayed',
              _hostShown: false,
              _projShown: false
            }));
          }
        });

        if (parsed.teams){
          state.teams = parsed.teams;
          state.settings.teamCount = Math.min(6, Math.max(2, state.teams.length));
        }
        state.currentRoundIndex = 0;
        undoStack = [];
        return true;
      }catch(e){
        alert('Invalid JSON. Please check your data and try again.');
        return false;
      }
    }

    // ----------------------------
    // Safe Mode (Projector reveal)
    // ----------------------------
    let projHoldTimer = null;
    function setupSafeProjectorRevealButton(){
      const btn = qs('#projAnswerBtn');
      if (!btn) return;

      btn.onmousedown = null;
      btn.onmouseup = null;
      btn.onmouseleave = null;
      btn.ontouchstart = null;
      btn.ontouchend = null;

      function clearHold(){
        if (projHoldTimer) clearTimeout(projHoldTimer);
        projHoldTimer = null;
        btn.style.filter = '';
      }

      function startHold(){
        if (!state.settings.safeMode){
          showAnswerProjector();
          return;
        }

        btn.style.filter = 'brightness(1.15)';
        projHoldTimer = setTimeout(() => {
          showAnswerProjector(true);
          clearHold();
        }, 700);
      }

      btn.onmousedown = startHold;
      btn.onmouseup = clearHold;
      btn.onmouseleave = clearHold;

      btn.ontouchstart = (e) => { e.preventDefault(); startHold(); };
      btn.ontouchend = (e) => { e.preventDefault(); clearHold(); };
    }

    // ----------------------------
    // Slot manager UI handlers
    // ----------------------------
    function openSlotModal(){
      qs('#backdrop').classList.add('show');
      qs('#slotModal').classList.add('show');
      qs('#slotModal').style.display = 'block';
      qs('#newSlotName').value = '';
      qs('#renameSlotName').value = '';
      qs('#duplicateSlotName').value = '';
    }

    function closeSlotModal(){
      qs('#slotModal').classList.remove('show');
      qs('#slotModal').style.display = 'none';
      qs('#backdrop').classList.remove('show');
    }

    function renameSlot(oldName, newName){
      const oldN = sanitizeSlotName(oldName) || 'Default';
      const newN = sanitizeSlotName(newName) || '';
      if (!newN){ alert('Please enter a new name.'); return false; }
      if (newN === oldN){ alert('That is already the current name.'); return false; }

      const slots = readSlotIndex();
      if (slots.includes(newN)){ alert('A slot with that name already exists.'); return false; }

      // Move saved payload if it exists
      try{
        const raw = localStorage.getItem(getSaveKey(oldN));
        if (raw){
          localStorage.setItem(getSaveKey(newN), raw);
          localStorage.removeItem(getSaveKey(oldN));
        }
      }catch(e){}

      // Update slot index
      const nextSlots = slots.map(s => (s === oldN ? newN : s));
      writeSlotIndex(nextSlots);

      // Update state slot
      state.settings.saveSlot = newN;

      renderSlotSelect(newN);
      return true;
    }

    function duplicateSlot(fromName, toName){
      const fromN = sanitizeSlotName(fromName) || 'Default';
      const toN = sanitizeSlotName(toName) || '';
      if (!toN){ alert('Please enter a new slot name.'); return false; }

      const slots = readSlotIndex();
      if (slots.includes(toN)){ alert('A slot with that name already exists.'); return false; }

      // Copy saved payload (or current in-memory state if none)
      try{
        const raw = localStorage.getItem(getSaveKey(fromN));
        if (raw){
          localStorage.setItem(getSaveKey(toN), raw);
        } else {
          // If no saved payload exists, clone current memory into new slot
          const payload = { state: deepClone(state), undoStack: deepClone(undoStack) };
          payload.state.settings.saveSlot = toN;
          localStorage.setItem(getSaveKey(toN), JSON.stringify(payload));
        }
      }catch(e){}

      ensureSlotExists(toN);
      renderSlotSelect(toN);
      return true;
    }

    function deleteSlot(name){
      const n = sanitizeSlotName(name) || 'Default';
      if (!confirm(`Delete slot "${n}"? This will delete its saved game.`)) return false;

      try{ localStorage.removeItem(getSaveKey(n)); }catch(e){}

      let slots = readSlotIndex().filter(s => s !== n);
      if (!slots.length) slots = ['Default'];
      writeSlotIndex(slots);

      const fallback = slots[0] || 'Default';
      setSlot(fallback, { loadIfExists: true });
      renderSlotSelect(fallback);
      return true;
    }

    // ----------------------------
    // Wire up UI
    // ----------------------------
    function wireTitleUI(){
      // Slot select change
      qs('#saveSlotSelect')?.addEventListener('change', () => {
        const slot = qs('#saveSlotSelect').value;
        setSlot(slot, { loadIfExists: true });
      });

      qs('#manageSlotsBtn')?.addEventListener('click', openSlotModal);
      qs('#closeSlotModalBtn')?.addEventListener('click', closeSlotModal);

      qs('#createSlotBtn')?.addEventListener('click', () => {
        const name = sanitizeSlotName(qs('#newSlotName').value);
        if (!name){ alert('Please enter a slot name.'); return; }
        ensureSlotExists(name);
        renderSlotSelect(name);
        setSlot(name, { loadIfExists: true });
        alert(`Created slot: "${name}"`);
      });

      qs('#renameSlotBtn')?.addEventListener('click', () => {
        const oldName = currentSlot();
        const newName = qs('#renameSlotName').value;
        if (renameSlot(oldName, newName)){
          alert(`Renamed "${oldName}" → "${sanitizeSlotName(newName)}"`);
          closeSlotModal();
        }
      });

      qs('#duplicateSlotBtn')?.addEventListener('click', () => {
        const fromName = currentSlot();
        const toName = qs('#duplicateSlotName').value;
        const toSan = sanitizeSlotName(toName);
        if (duplicateSlot(fromName, toName)){
          alert(`Duplicated "${fromName}" → "${toSan}"`);
          closeSlotModal();
        }
      });

      qs('#deleteSlotBtn')?.addEventListener('click', () => {
        if (deleteSlot(currentSlot())){
          closeSlotModal();
        }
      });

      // Copy template
      qs('#copyJsonTemplateBtn')?.addEventListener('click', () => {
        copyToClipboard(jsonTemplate());
        alert('JSON template copied.');
      });

      // Clear current slot save
      qs('#clearSaveBtn').addEventListener('click', () => {
        const slot = currentSlot();
        const ok = confirm(`Clear saved GEFFEN BOWL game state for slot "${slot}"?`);
        if (!ok) return;
        clearSaved();
        renderSlotSelect(slot);
        qs('#jsonInputTitle').placeholder = `No saved game in "${slot}" yet. Paste JSON or use the Builder.`;
        alert('Saved game cleared.');
      });

      // Export/Import
      qs('#exportSaveBtn')?.addEventListener('click', exportSaveToFile);
      qs('#importSaveBtn')?.addEventListener('click', () => qs('#importFileInput').click());
      qs('#importFileInput')?.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        importSaveFromFile(file);
        e.target.value = '';
      });

      qs('#pasteJsonFromTitle').addEventListener('click', () => {
        qs('#jsonInputTitle').focus();
      });

      qs('#openBuilderFromTitle').addEventListener('click', () => {
        if (!state.rounds?.length) state.rounds = [{ id:'r1_'+nowId(), title:'Round 1', categories:{} }];
        openBuilder();
      });

      qs('#startFromTitle').addEventListener('click', () => {
        // apply settings from title UI
        const teamCount = clampInt(qs('#teamCount').value, 3);
        const mode = qs('#gameMode').value;
        const timerDefault = clampInt(qs('#timerDefault').value, 10);

        state.settings.autosave = !!qs('#autosaveToggle').checked;
        state.settings.projectorEnabled = !!qs('#projectorToggle').checked;
        state.settings.safeMode = !!qs('#safeModeToggle').checked;
        state.settings.defaultRevealBoth = !!qs('#defaultRevealBothToggle').checked;

        setTeamCount(teamCount);
        state.settings.timerDefault = timerDefault;
        applyModePreset(mode);

        // try to load JSON if present (overwrites questions)
        loadQuestionsFromTitleTextarea();

        qs('#timerDefaultReadout').innerText = String(state.settings.timerDefault);
        qs('#safeModeReadout').innerText = state.settings.safeMode ? 'ON' : 'OFF';

        setupSafeProjectorRevealButton();
        titleToGame();

        if (state.settings.projectorEnabled){
          broadcastState();
        }
      });
    }

    function wireGameUI(){
      qs('#returnToTitleBtn').addEventListener('click', () => {
        const ok = confirm('Return to title screen? (Game state remains saved if Autosave is on.)');
        if (!ok) return;
        closeQuestion();
        closeBuilder();
        showTitle();
        saveState();
      });

      qs('#toggleDoubleBtn').addEventListener('click', toggleDouble);

      qs('#copyJsonBtn').addEventListener('click', () => {
        const json = exportJson();
        copyToClipboard(json);
        alert('Current JSON copied.');
      });

      qs('#openBuilderBtn').addEventListener('click', () => openBuilder());
      qs('#openProjectorBtn').addEventListener('click', () => openProjectorWindow());
qs('#nextRoundBtn').addEventListener('click', () => {
  nextRoundIfAvailable();
});
      qs('#projectorFullscreenBtn').addEventListener('click', () => {
        try{ document.documentElement.requestFullscreen(); }catch(e){}
      });

      qs('#noTeamBtn').addEventListener('click', noTeamCorrect);

      qs('#hostAnswerBtn').addEventListener('click', () => {
        if (state.settings.defaultRevealBoth) showAnswerBoth();
        else showAnswerHost(true);
      });

      qs('#bothAnswerBtn').addEventListener('click', showAnswerBoth);
      qs('#pauseBtn').addEventListener('click', pauseTimer);
      qs('#closeQuestionBtn').addEventListener('click', closeQuestion);

      setupSafeProjectorRevealButton();

      qs('#startRoundBtn').addEventListener('click', startRound);

      qs('#backdrop').addEventListener('click', () => {
        if (qs('#slotModal')?.classList.contains('show')) closeSlotModal();
        if (qs('#builder').classList.contains('show')) closeBuilder();
        if (qs('#questionModal').classList.contains('show')) closeQuestion();
      });

      qs('#builderCloseBtn').addEventListener('click', closeBuilder);
      qs('#builderAddCategoryBtn').addEventListener('click', addCategory);
      qs('#builderAddRoundBtn').addEventListener('click', addRound);
      qs('#builderCopyJsonBtn').addEventListener('click', () => {
        copyToClipboard(exportJson());
        alert('JSON copied.');
      });

      document.addEventListener('keydown', (e) => {
        if (isProjectorView) return;

        const modalOpen = qs('#questionModal').classList.contains('show');
        const builderOpen = qs('#builder').classList.contains('show');
        const slotOpen = qs('#slotModal')?.classList.contains('show');

        const isEditing = document.activeElement && (
          document.activeElement.isContentEditable ||
          ['TEXTAREA','INPUT','SELECT'].includes(document.activeElement.tagName)
        );

        if (slotOpen){
          if (e.key === 'Escape'){ e.preventDefault(); closeSlotModal(); }
          return;
        }

        if (isEditing && e.key !== 'Escape') return;

        if (builderOpen){
          if (e.key === 'Escape'){ e.preventDefault(); closeBuilder(); }
          return;
        }

        if (modalOpen){
          if (e.key === 'Escape'){ e.preventDefault(); closeQuestion(); return; }
          if (e.key === ' '){ e.preventDefault(); pauseTimer(); return; }

          if (e.key.toLowerCase() === 'a'){
            if (e.shiftKey){
              e.preventDefault();
              if (state.settings.safeMode){
                const ok = confirm('SAFE MODE: Reveal answer on projector?');
                if (ok) showAnswerProjector(true);
              } else {
                showAnswerProjector();
              }
            } else {
              e.preventDefault();
              if (state.settings.defaultRevealBoth) showAnswerBoth();
              else showAnswerHost(true);
            }
            return;
          }

          const n = clampInt(e.key, -1);
          if (n >= 1 && n <= 6){
            e.preventDefault();
            if (n <= state.teams.length) awardToTeam(n - 1);
            return;
          }
        } else {
          if (e.key.toLowerCase() === 'u'){ e.preventDefault(); undoLast(); return; }
        }
      });
    }

    function copyToClipboard(text){
      const temp = document.createElement('textarea');
      temp.value = text;
      document.body.appendChild(temp);
      temp.select();
      document.execCommand('copy');
      document.body.removeChild(temp);
    }

    // ----------------------------
    // Projector window open + handshake
    // ----------------------------
    function openProjectorWindow(){
      if (isProjectorView) return;
      if (!state.settings.projectorEnabled){
        alert('Projector Mode is disabled on the title screen settings.');
        return;
      }

      const url = new URL(location.href);
      url.searchParams.set('view', 'projector');

      projectorWin = window.open(url.toString(), 'GEFFEN_BOWL_PROJECTOR', 'popup,width=1200,height=800');
      if (!projectorWin){
        alert('Popup blocked. Allow popups for this page, then try again.');
        return;
      }

      state.projector.connected = false;
      renderProjectorConnectedUI(false);

      setTimeout(() => {
        sendToProjector({ type:'PING' });
        broadcastState();
      }, 300);
    }

    // ----------------------------
    // Starfield (1993 vibe)
    // ----------------------------
    function initStarfield(){
      const c1 = qs('#starfield');
      const c2 = qs('#starfield2');
      if (!c1 || !c2) return;

      const ctx1 = c1.getContext('2d');
      const ctx2 = c2.getContext('2d');

      let w=0,h=0, dpr=1;

      function resize(){
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        w = Math.floor(window.innerWidth * dpr);
        h = Math.floor(window.innerHeight * dpr);
        c1.width = w; c1.height = h;
        c2.width = w; c2.height = h;
        c1.style.width = '100%'; c1.style.height='100%';
        c2.style.width = '100%'; c2.style.height='100%';
      }
      window.addEventListener('resize', resize);
      resize();

      const starsA = Array.from({length: 220}, () => ({
        x: Math.random()*w,
        y: Math.random()*h,
        z: Math.random()*1,
        s: 0.6 + Math.random()*1.4,
        v: 0.25 + Math.random()*0.8
      }));

      const starsB = Array.from({length: 90}, () => ({
        x: Math.random()*w,
        y: Math.random()*h,
        s: 1.2 + Math.random()*2.2,
        v: 0.55 + Math.random()*1.2
      }));

      let t=0;

      function step(){
        t += 0.016;

        ctx1.clearRect(0,0,w,h);
        ctx1.fillStyle = 'rgba(255,255,255,.9)';
        for (const s of starsA){
          s.y += s.v * dpr * 1.2;
          s.x += Math.sin(t*0.7 + s.z*10) * 0.12 * dpr;
          if (s.y > h) { s.y = -10; s.x = Math.random()*w; }
          ctx1.globalAlpha = 0.55 + s.z*0.35;
          ctx1.fillRect(s.x, s.y, s.s*dpr*0.8, s.s*dpr*0.8);
        }

        ctx2.clearRect(0,0,w,h);
        for (const s of starsB){
          s.y += s.v * dpr * 2.4;
          if (s.y > h){ s.y = -30; s.x = Math.random()*w; }
          const glow = 0.35 + Math.sin(t*2 + s.x*0.002)*0.15;
          ctx2.globalAlpha = glow;
          ctx2.fillStyle = 'rgba(45,125,255,.8)';
          ctx2.fillRect(s.x, s.y, s.s*dpr*0.5, s.s*dpr*2.5);

          ctx2.globalAlpha = glow*0.8;
          ctx2.fillStyle = 'rgba(255,224,102,.85)';
          ctx2.fillRect(s.x + 2*dpr, s.y + 4*dpr, s.s*dpr*0.35, s.s*dpr*1.7);
        }

        requestAnimationFrame(step);
      }
      step();
    }

    // ----------------------------
    // Boot
    // ----------------------------
    function boot(){
      initStarfield();

      if (isProjectorView){
        showGame();
        qs('#subtitle').innerText = 'PROJECTOR VIEW • read-only';
        qs('#openProjectorBtn')?.remove();
        qs('#returnToTitleBtn')?.remove();
        qs('#openBuilderBtn')?.remove();
        qs('#copyJsonBtn')?.remove();
        qs('#toggleDoubleBtn')?.remove();

        qs('#projHint').style.display = 'inline-block';
        renderProjectorStatus();

        onProjectorMessage(handleIncoming);

        setTimeout(() => {
          sendToProjector({ type:'PING' });
        }, 250);

        renderTeams();
        renderBoard();
        return;
      }

      // Ensure slot index exists + set default slot
      state.settings.saveSlot = ensureSlotExists(state.settings.saveSlot || 'Default');
      renderSlotSelect(state.settings.saveSlot);

      // Attempt to load from selected slot
      const loaded = loadStateForSlot(state.settings.saveSlot);

      // Initialize title UI from state
      qs('#teamCount').value = String(state.settings.teamCount || 3);
      qs('#gameMode').value = state.settings.mode || 'classic';
      qs('#timerDefault').value = String(state.settings.timerDefault || 10);

      qs('#autosaveToggle').checked = !!state.settings.autosave;
      qs('#projectorToggle').checked = !!state.settings.projectorEnabled;
      qs('#safeModeToggle').checked = !!state.settings.safeMode;
      qs('#defaultRevealBothToggle').checked = !!state.settings.defaultRevealBoth;

      // Update placeholder based on slot save existence
      const slot = currentSlot();
      qs('#jsonInputTitle').placeholder = slotHasSave(slot)
        ? `Saved game detected in "${slot}". Click Start to resume, or paste JSON to overwrite.`
        : `No saved game in "${slot}" yet. Paste JSON or use the Builder.`;

      wireTitleUI();
      wireGameUI();

      onProjectorMessage(handleIncoming);

      // If slot loaded successfully, keep it on title but ready to resume
      if (loaded){
        // nothing else needed; Start resumes
      }

      showTitle();
    }

    boot();
  </script>
</body>
</html>
